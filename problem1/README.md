# Анализ влияния кэша на операцию матричного умножения

## Теоретические оценки

Для "IJK" и "JIK" алгоритма, число промахов кэша за шаг:
| A | B | C |
| ---- | --- | --- |
| 0.25 | 1.0 | 0.0 |

Итого 1.25 кэш-промахов, а также 2 операции чтения и 0 операций записи за 1 итерацию.

Для "IKJ" и "KIJ" алгоритма, число промахов кэша за шаг:
| A | B | C |
| --- | ---- | ---- |
| 0.0 | 0.25 | 0.25 |

Итого 0.5 кэш-промахов, а также 2 операции чтения и 1 операция записи за 1 итерацию.

Для "JKI" и "KJI алгоритма, число промахов кэша за шаг:
| A | B | C |
| --- | --- | --- |
| 1.0 | 0.0 | 1.0 |

Итого 2 кэш-промаха, а также 2 операции чтения и 1 операция записи за 1 итерацию.

## Практические результаты

Рассмотрены 6 вариантов матричного умножения, для разных типов данных - int32_t (4 байта для хранения одного элемента массива) и int64_t (8 байт соответственно).
Размер матриц - NROWS = 1000.
Соотвественно, для хранения матрицы (10^6) элементов, типа int32_t - нужно около 3.8Mb, а для хранения int64_t - около 7.6Mb соответственно.

1. ijk
> int32_t time: 3.87275

> int64_t time: 5.47724
2. ikj
> int32_t time: 3.70860

> int64_t time: 3.74076
3. kij
> int32_t time: 3.67438

> int64_t time: 3.77151
4. jik
> int32_t time: 3.48088

> int64_t time: 4.14612
5. jki
> int32_t time: 8.86315

> int64_t time: 10.13509
6. kji
> int32_t time: 8.73079

> int64_t time: 10.12970

В общем случае, практические результаты подтверждают теоретические теоретические - об оценке эффективности алгоритмов по использованию кэша.
Однако, стоит учитывать, что есть множество других факторов, влияющих на производительность, например разгон процессора (увеличение тактовой частоты), или выполнение каких-либо других процессов.
